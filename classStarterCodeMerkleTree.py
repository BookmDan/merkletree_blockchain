import hashlib
import os

# Task 1: Hash Function
def hash_file(file_path):
    """
    Computes the SHA-256 hash of the file at the given path.
    
    Args:
        file_path (str): The path to the file.
    
    Returns:
        str: The SHA-256 hash of the file contents.
    """
    sha256 = hashlib.sha256()
    with open(file_path, 'rb') as f:
        for block in iter(lambda: f.read(4096), b""):
            sha256.update(block)
    return sha256.hexdigest()

class Node:
    def __init__(self, hash_value, left=None, right=None, is_leaf=False, file_path=None):
        """
        Initializes a node in the Merkle Tree.

        Args:
            hash_value (str): The hash value of the node.
            left (Node): The left child node.
            right (Node): The right child node.
            is_leaf (bool): True if the node is a leaf node, False otherwise.
            file_path (str): The file path if the node is a leaf node.
        """
        self.hash_value = hash_value
        self.left = left
        self.right = right
        self.is_leaf = is_leaf
        self.file_path = file_path
        self.parent = None 

    def __repr__(self):
        if self.is_leaf:
            return f"LeafNode(hash_value={self.hash_value}, file_path={self.file_path})"
        else:
            return f"InternalNode(hash_value={self.hash_value})"

# Task 2: Merkle Tree Construction
class MerkleTree:
    def __init__(self):
        """
        Initializes an empty Merkle Tree.
        """
        self.leaf_nodes = []
        self.root = None

    def add_file_commitment(self, file_path):
        """
        Adds the hash of the file at file_path as a leaf node in the Merkle Tree.
        Updates the tree structure.
        
        Args:
            file_path (str): The path to the file to be added.
        """
        file_hash = hash_file(file_path)
        new_node = Node(hash_value=file_hash, is_leaf=True, file_path=file_path)
        self.leaf_nodes.append(new_node)
        self._build_tree()

    def _build_tree(self):
        """
        Builds the Merkle Tree from the leaf nodes up to the root.
        """
        nodes = self.leaf_nodes[:]
        while len(nodes) > 1:
            if len(nodes) % 2 != 0:
                nodes.append(nodes[-1])  # Duplicate the last node if odd number of nodes
            new_level = []
            for i in range(0, len(nodes), 2):
                left_node = nodes[i]
                right_node = nodes[i + 1]
                combined_hash = hashlib.sha256((left_node.hash_value + right_node.hash_value).encode('utf-8')).hexdigest()
                parent_node = Node(hash_value=combined_hash, left=left_node, right=right_node)
                left_node.parent = parent_node
                right_node.parent = parent_node
                new_level.append(parent_node)
                # new_level.append(Node(hash_value=combined_hash, left=left_node, right=right_node))
            nodes = new_level
        self.root = nodes[0] if nodes else None

    def generate_proof(self, index):
        """
        Generates a proof for the leaf node at the given index.
        
        Args:
            index (int): The index of the leaf node.
        
        Returns:
            list: A list of hashes representing the proof.
        """
        proof = []
        node = self.leaf_nodes[index]
        while node != self.root:
            parent = node.parent
            if parent.left == node:
                sibling = parent.right
            else:
                sibling = parent.left
            proof.append(sibling.hash_value)
            node = parent
        return proof

    def get_root(self):
        """
        Returns the root hash of the Merkle Tree.
        
        Returns:
            str: The root hash of the Merkle Tree.
        """
        return self.root.hash_value if self.root else None

# Task 3: Integrity Check
def verify_file(root_hash, proof, file_path):
    """
    Verifies the integrity of the file at file_path using the given root hash and proof.
    
    Args:
        root_hash (str): The root hash of the Merkle Tree.
        proof (list): The proof generated by the Merkle Tree.
        file_path (str): The path to the file to be verified.
    
    Returns:
        bool: True if the file is verified, False otherwise.
    """
    file_hash = hash_file(file_path)
    combined_hash = file_hash

    for i, hash_value in enumerate(proof):
        if i % 2 == 0: #left sibling
            combined_hash = hashlib.sha256((hash_value + combined_hash).encode('utf-8')).hexdigest()
        else: #right sibling
            combined_hash = hashlib.sha256((combined_hash + hash_value).encode('utf-8')).hexdigest()

    return combined_hash == root_hash

# Task 4: Testing
def main():
    # List of test files
    files = ["file1.txt", "file2.txt", "file3.txt"]
    
    # Create test files with content
    for file in files:
        with open(file, 'w') as f:
            f.write(f"Content of {file}")

    merkle_tree = MerkleTree()

    # Add files to the Merkle Tree
    for file in files:
        merkle_tree.add_file_commitment(file)

    # Get the root hash of the Merkle Tree
    root_hash = merkle_tree.get_root()
    print(f"Merkle Tree Root Hash: {root_hash}")

    # Generate proof for one of the files
    test_file = files[1]
    proof = merkle_tree.generate_proof(files.index(test_file))

    print(f"Proof for {test_file}: {proof}")

    # Create a modified version of the test file
    original_file_path = test_file
    modified_file_path = "modified_" + test_file

    with open(modified_file_path, 'w') as f:
        f.write("Modified content")

    # Verify the original and modified files
    is_original_valid = verify_file(root_hash, proof, original_file_path)
    is_modified_valid = verify_file(root_hash, proof, modified_file_path)

    print(f"Original file validation: {is_original_valid}")
    print(f"Modified file validation: {is_modified_valid}")

    # Clean up the created files
    for file in files + [modified_file_path]:
        os.remove(file)

if __name__ == "__main__":
    main()
